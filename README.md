Here's the formatted `README.md` file:

```markdown
# React & JavaScript Concepts

## ‚ùì Why does a React component need to return a single root element?

‚úÖ **Answer:**  
React components must return a single root element because the JSX returned from a component gets compiled into `React.createElement()` calls, and that function expects only one parent element to wrap all child elements. If multiple siblings are returned without a parent, it causes a syntax error.

‚úÖ **Bonus Tip:**  
Instead of adding unnecessary `<div>`s, you can use React Fragments (`<>...</>`) to avoid adding extra nodes to the DOM:

```jsx
return (
  <>
    <h1>Title</h1>
    <p>Subtitle</p>
  </>
)
```

‚úÖ **Simple Answer:**  
React needs everything inside one main wrapper because it can only return one thing from a component. If you try to return two separate tags side by side, React gets confused and gives an error.

---

## üîÑ React Component Lifecycle

```
        User Action (e.g., Button Click)
                    ‚Üì
        Event Handler Function Runs (e.g., onClick ‚Üí setState)
                    ‚Üì
              State is Updated
                    ‚Üì
          Component Re-renders (JSX re-evaluated)
                    ‚Üì
          DOM is Updated (Visible Changes Applied)
                    ‚Üì
          useEffect Cleanup Runs (if dependencies changed)
                    ‚Üì
              New useEffect Runs
```

### React Component Lifecycle Diagram
```
+------------------------------------------------------+
|             üîÑ React Component Lifecycle             |
+------------------------------------------------------+
|                                                      |
| 1. User triggers an event (e.g., button click)       |
|        ‚Üì                                             |
| 2. Event handler runs (e.g., setState)               |
|        ‚Üì                                             |
| 3. Component re-renders (function runs again)        |
|        ‚Üì                                             |
| 4. Virtual DOM is updated                            |
|        ‚Üì                                             |
| 5. React updates the actual DOM                      |
|        ‚Üì                                             |
| 6. Previous useEffect cleanup runs (if needed)       |
|        ‚Üì                                             |
| 7. New useEffect runs (after render)                 |
|                                                      |
+------------------------------------------------------+
```

### useEffect Lifecycle in React
```
+--------------------------------------------------------------+
|                  üîÅ useEffect Lifecycle in React             |
+--------------------------------------------------------------+
|                                                              |
| 1. Component mounts                                          |
|    ‚Üí useEffect runs **after** the initial render             |
|                                                              |
| 2. On re-render (due to state/prop change):                  |
|    ‚Üí If dependencies changed:                                |
|       a. Previous useEffect cleanup runs                     |
|       b. Then new useEffect runs **after** DOM update        |
|                                                              |
| 3. If component unmounts:                                    |
|    ‚Üí Cleanup function (if provided) runs                     |
|                                                              |
| ‚úÖ useEffect runs:                                            |
|    - After DOM update                                        |
|    - On mount                                                |
|    - On dependency change                                    |
|    - Before unmount (cleanup)                                |
|                                                              |
+--------------------------------------------------------------+
```

---

## üîÑ JavaScript Event Loop

```
+----------------------------------------------------------+
|                    üîÑ Event Loop                         |
+----------------------------------------------------------+
|                                                          |
| JavaScript is **single-threaded** ‚Äî it runs 1 thing at a |
| time. But it can handle async tasks like setTimeout,     |
| fetch, etc., using the **Event Loop**.                   |
|                                                          |
| üß† Main Parts:                                            |
| 1. Call Stack ‚Äì runs your code line by line              |
| 2. Web APIs ‚Äì handles async things (timers, fetch, etc.) |
| 3. Callback Queue ‚Äì stores completed async tasks         |
| 4. Event Loop ‚Äì moves tasks from queue ‚Üí call stack      |
|                                                          |
| üîÅ The Event Loop checks:                                 |
|    ‚Üí Is call stack empty?                                |
|       ‚úÖ Yes ‚Üí take 1 task from queue ‚Üí run it            |
|       ‚ùå No ‚Üí wait                                        |
|                                                          |
| This is how JS stays non-blocking and fast.              |
+----------------------------------------------------------+
```

### Real Example: Event Loop
```
+------------------------------------------------------+
|            ‚öôÔ∏è Real Example: Event Loop               |
+------------------------------------------------------+
|                                                      |
| ‚û§ Code:                                              |
|  +----------------------------------------------+    |
|  | console.log("1");                            |    |
|  | setTimeout(() => {                           |    |
|  |   console.log("2");                          |    |
|  | }, 0);                                       |    |
|  | console.log("3");                            |    |
|  +----------------------------------------------+    |
|                                                      |
| ‚û§ Output:                                            |
|  +----------------+                                  |
|  | 1              |                                  |
|  | 3              |                                  |
|  | 2              |                                  |
|  +----------------+                                  |
|                                                      |
| ‚úÖ Explanation:                                      |
| - "1" prints first (sync)                            |
| - setTimeout is async, so it's delayed               |
| - "3" prints next                                    |
| - Then "2" runs via Event Loop                       |
+------------------------------------------------------+
```

### Event Loop Connections
| Concept            | Role in Event Loop                                   |
|--------------------|-----------------------------------------------------|
| Callback           | Goes to Callback Queue and waits for call stack to clear |
| setTimeout         | Timer finishes ‚Üí callback queued ‚Üí Event loop picks it |
| Promise            | `.then()`/`.catch()` go to Microtask Queue          |
| async/await        | Uses promises and microtasks behind the scenes      |
| Event Loop         | Controls when tasks from queues are run             |

---

## üß© Types of Functions in JavaScript

```
+---------------------------------------------------------------+
|             üß© Types of Functions in JavaScript               |
+---------------------------------------------------------------+

| üìå 1. Function Declaration                                    |
|   +------------------------ Code --------------------------+ |
|   | function greet() {                                      | |
|   |   console.log("Hello");                                 | |
|   | }                                                       | |
|   | greet();                                                | |
|   +--------------------------------------------------------+ |
|   +------------------------ Output ------------------------+ |
|   | Hello                                                   | |
|   +--------------------------------------------------------+ |

| üìå 2. Function Expression                                     |
|   +------------------------ Code --------------------------+ |
|   | const greet = function() {                              | |
|   |   console.log("Hi");                                    | |
|   | };                                                      | |
|   | greet();                                                | |
|   +--------------------------------------------------------+ |
|   +------------------------ Output ------------------------+ |
|   | Hi                                                      | |
|   +--------------------------------------------------------+ |

| üìå 3. Arrow Function                                          |
|   +------------------------ Code --------------------------+ |
|   | const add = (a, b) => a + b;                            | |
|   | console.log(add(2, 3));                                 | |
|   +--------------------------------------------------------+ |
|   +------------------------ Output ------------------------+ |
|   | 5                                                       | |
|   +--------------------------------------------------------+ |

| üìå 4. Anonymous Function                                      |
|   +------------------------ Code --------------------------+ |
|   | setTimeout(function() {                                 | |
|   |   console.log("Delayed");                               | |
|   | }, 1000);                                               | |
|   +--------------------------------------------------------+ |
|   +------------------------ Output ------------------------+ |
|   | Delayed (after 1 sec)                                   | |
|   +--------------------------------------------------------+ |

| üìå 5. IIFE (Immediately Invoked Function Expression)         |
|   +------------------------ Code --------------------------+ |
|   | (function() {                                            | |
|   |   console.log("IIFE ran");                               | |
|   | })();                                                    | |
|   +--------------------------------------------------------+ |
|   +------------------------ Output ------------------------+ |
|   | IIFE ran                                                 | |
|   +--------------------------------------------------------+ |

| üìå 6. Callback Function                                       |
|   +------------------------ Code --------------------------+ |
|   | function greet(name, cb) {                               | |
|   |   cb(name);                                              | |
|   | }                                                        | |
|   | greet("Akshit", function(n) {                            | |
|   |   console.log("Hello " + n);                             | |
|   | });                                                      | |
|   +--------------------------------------------------------+ |
|   +------------------------ Output ------------------------+ |
|   | Hello Akshit                                             | |
|   +--------------------------------------------------------+ |
+---------------------------------------------------------------+
```

---

## ‚è≥ How Promises Work

```
+------------------------------------------------------+
|                   ‚è≥ How Promises Work               |
+------------------------------------------------------+
| A Promise is an object that represents an async task |
| that may:                                             |
|   - ‚úÖ Resolve (Success)                              |
|   - ‚ùå Reject (Failure)                               |
|                                                      |
| States:                                               |
| 1. Pending ‚Üí 2. Fulfilled / Rejected                 |
|                                                      |
| Usage:                                                |
| const promise = new Promise((resolve, reject) => {   |
|     async work here                                  |
|     resolve("Done!") / reject("Error")               |
| });                                                   |
|                                                      |
| promise.then(result).catch(error);                   |
|                                                      |
| üìå Promises go to Microtask Queue after resolve/reject|
+------------------------------------------------------+
```

---

## üîÅ How async/await Works

```
+------------------------------------------------------+
|                 üîÅ How async/await Works             |
+------------------------------------------------------+
| async/await is a cleaner way to use Promises         |
|                                                      |
| - `async` marks a function to return a Promise       |
| - `await` pauses the function until Promise resolves |
|                                                      |
| Example:                                              |
| async function fetchData() {                         |
|   const res = await fetch("url");                    |
|   const data = await res.json();                     |
|   console.log(data);                                 |
| }                                                    |
|                                                      |
| üìå Inside, it's still using Promises & Microtasks    |
| üìå Errors are handled with try...catch               |
+------------------------------------------------------+
```

---

## üîÅ Currying in JavaScript

```
+---------------------------------------------------------------+
|                      üîÅ Currying in JavaScript                |
+---------------------------------------------------------------+

| üí° Currying is a technique of breaking a function             |
|    with multiple arguments into a series of functions         |
|    that take one argument at a time.                          |

| üíª Code:                                                      |
|   +------------------------ Code --------------------------+ |
|   | function multiply(a) {                                  | |
|   |   return function(b) {                                  | |
|   |     return a * b;                                       | |
|   |   };                                                    | |
|   | }                                                       | |
|   | const double = multiply(2);                             | |
|   | console.log(double(5));                                 | |
|   +--------------------------------------------------------+ |

| üì§ Output:                                                    |
|   +------------------------ Output ------------------------+ |
|   | 10                                                       | |
|   +--------------------------------------------------------+ |

| ‚úÖ Explanation:                                               |
|   - `multiply(2)` returns a new function                     |
|   - That function remembers `a = 2` and takes `b = 5`        |
|   - Returns 2 * 5 = 10                                       |
+---------------------------------------------------------------+
```

---

## üîí Closures in JavaScript

```
+---------------------------------------------------------------+
|                     üîí Closures in JavaScript                 |
+---------------------------------------------------------------+

| üí° A closure is when a function "remembers" the               |
|    variables from its lexical scope even after the outer     |
|    function has finished execution.                          |

| üíª Code:                                                      |
|   +------------------------ Code --------------------------+ |
|   | function outer() {                                      | |
|   |   let counter = 0;                                      | |
|   |   return function inner() {                             | |
|   |     counter++;                                          | |
|   |     console.log(counter);                               | |
|   |   };                                                    | |
|   | }                                                       | |
|   | const count = outer();                                  | |
|   | count();  count();  count();                            | |
|   +--------------------------------------------------------+ |

| üì§ Output:                                                    |
|   +------------------------ Output ------------------------+ |
|   | 1                                                       | |
|   | 2                                                       | |
|   | 3                                                       | |
|   +--------------------------------------------------------+ |

| ‚úÖ Explanation:                                               |
|   - `inner()` remembers `counter` from `outer()`             |
|   - Even after `outer()` is done, `counter` lives on         |
|   - This is a **closure**                                    |
+---------------------------------------------------------------+
```
![Variable in Hooks](./interview-questions/var-in-hooks.png)
